// Hover messages

#include "TeamColour.as"

// Linear interpolation
// TODO: expose in engine
float lerp(float v0, float v1, float t)
{
	return (1.0f - t) * v0 + t * v1;
}

Vec2f lerp(Vec2f v0, Vec2f v1, float t)
{
	return Vec2f(lerp(v0.x, v1.x, t),
				 lerp(v0.y, v1.y, t));
}

class MessageToken
{
	string text;
	SColor color;
	Vec2f offset;

	MessageToken(
		const string&in p_text,
		const SColor&in p_color = color_white,
		const Vec2f&in p_offset = Vec2f()
	)
	{
		text = p_text;
		color = p_color;
		offset = p_offset;
	}
};

// Message type category
// This is used to split messages into different categories which are then easier to manage
// Messages of a given type are rendered together.
// e.g. if you earn 200 stone, kill somebody, earn 100 wood, the resource messages will be shown together
enum MessageTypes
{
	MESSAGE_NONE,
	MESSAGE_KILLSPREE,
	MESSAGE_ASSIST,
	MESSAGE_MATERIAL,
    MESSAGE_DAMAGETAKEN,
    MESSAGE_HEALTAKEN,
    MESSAGE_DAMAGEDEALT,
    MESSAGE_HEALDEALT,
	MESSAGE_TOTAL
};

// Base hover message class. Treat this as an abstract class; you *must* implement generate_tokens in
// an inherited class and optionally can implement reset_time and try_merge. You also *must* assign
// the hovermessage to a unique category.
class HoverMessage
{
	// In the constructor from your inherited 
	MessageTypes category;
	
	// Time left, in seconds, for the message display.
	// This is updated by render().
	// When the countdown reaches 0, the message is removed from the list.
	float time_left;
	float kickout_effect;

	// Mark the hover message to be garbage collected regardless of the time left
	bool force_gc;

	// Message tokens. They are chunks of texts with their own color and offset, from a base offset.
	MessageToken[] tokens;

	HoverMessage()
	{
		reset_time();
		force_gc = false;
		kickout_effect = 0;
	}

	// Reset the timer to a value given in seconds.
	// Override this if you want to change your message default duration.
	void reset_time()
	{
		time_left = 6.0f;
	}

	// Forces the tokens to be recreated. This is useful when merging messages or when needing to
	// provide any update to the displayed message.
	void refresh_tokens()
	{
		tokens.clear();
		generate_tokens();
	}

	// You must override this in inherited classes!
	// This is the function that, when called, generates tokens for this message from the internal data.
	void generate_tokens() {}

	// Unless you need to be able to merge messages (e.g. KillSpreeMessage,  MaterialMessage or AssistMessage),
	// you do not need to override this. When adding a new message, HoverMessages will first try to merge
	// the new message to every message of the *same category* in the list. This implies you can assume
	// that any parameter passed to try_merge() will be of the type of your inherited class, so you can do
	// MyCustomMessage@ message = cast<MyCustomMessage>(other);
	// Return 'this' on success, 'null' on failure.
	HoverMessage@ try_merge(HoverMessage@ other)
	{
		return null;
	}

	// Renders the tokens previously generated by generate_tokens().
	// This updates time_left and the HoverMessages past offset and past total offsets.
	void render(HoverMessages@ messages, Vec2f base_offset)
	{
		time_left -= getRenderDeltaTime();

		for (int i = 0; i < tokens.length; ++i)
		{
			MessageToken@ t = tokens[i];

			// Apply fade-out
			t.color.setAlpha((t.color.getAlpha() / 255.f) * Maths::Clamp(time_left, 0.0f, 1.0f) * 255.0f);

			// Kick-out effect: a subtle movement to the right applied along with the fade-out.
			kickout_effect = Maths::Clamp(1.0f - time_left, 0.0f, 1.0f) * 32.0f;

			Vec2f text_dimensions;
			GUI::GetTextDimensions(t.text, text_dimensions);

			messages.past_offset.y += text_dimensions.y;
			messages.past_total_offset.x = Maths::Max(messages.past_total_offset.x, messages.past_offset.x);
			messages.past_total_offset.y = Maths::Max(messages.past_total_offset.y, messages.past_offset.y);

			GUI::DrawTextCentered(
				t.text,
				base_offset + Vec2f(0,72) + t.offset + Vec2f(0, kickout_effect),
				t.color
			);
		}
	}
};

class PlayerMessageInfo
{
	u8 team;
	string clantag;
	string username;
};

/*
	Killspree messages. Looks like:

	  clantag character name
		vvvvv vvvvvvvvvvv
	+3  [RUS] randomguy40
	    dog copper40
	    Sedgewick
*/
class KillSpreeMessage : HoverMessage
{
	PlayerMessageInfo[] victims;

	KillSpreeMessage(CPlayer@ player)
	{
		category = MESSAGE_KILLSPREE;

		PlayerMessageInfo info;
		info.team = player.getTeamNum();
		info.clantag = player.getClantag();
		info.username = player.getCharacterName();

		victims.push_back(info);
	}

	void generate_tokens() override
	{
		string kill_counter = "+" + victims.length;
		Vec2f offset;
		GUI::GetTextDimensions(kill_counter, offset);
		offset = Vec2f(-offset.x / 2, 0.0f);

		for (uint i = 0; i < victims.length; ++i)
		{
			string clantag = victims[i].clantag;

			if (!clantag.isEmpty())
			{
				tokens.push_back(MessageToken(clantag, SColor(255, 127, 127, 127), offset));
			}

			Vec2f clantag_dimensions;
			GUI::GetTextDimensions(clantag, clantag_dimensions);

			string username = victims[i].username;

			Vec2f username_dimensions;
			GUI::GetTextDimensions(username, username_dimensions);

			if (!username.isEmpty())
			{
				tokens.push_back(
					MessageToken(
						username,
						getTeamColor(victims[i].team),
						offset + Vec2f(clantag_dimensions.x + 6.0f, 0.0f)
					)
				);
			}

			if (i == 0) tokens.push_back(MessageToken(kill_counter, SColor(255, 255, 0, 0), Vec2f(-username_dimensions.x/2 - 20.0f,0)));

			offset.y += Maths::Max(clantag_dimensions.y, username_dimensions.y);
		}
	}

	HoverMessage@ try_merge(HoverMessage@ other) override
	{
		KillSpreeMessage@ message = cast<KillSpreeMessage>(other);

		for (uint i = 0; i < message.victims.length; ++i)
		{
			victims.push_back(message.victims[i]);
		}

		return this;
	}
};

/*
	Assist messages. Looks like:

	  clantag character name
		vvvvv vvvvvvvvvvv
	+3  [RUS] randomguy40
	    dog copper40
	    Sedgewick
*/
class AssistMessage : HoverMessage
{
	PlayerMessageInfo[] victims;

	AssistMessage(CPlayer@ player)
	{
		category = MESSAGE_ASSIST;

		PlayerMessageInfo info;
		info.team = player.getTeamNum();
		info.clantag = player.getClantag();
		info.username = player.getCharacterName();

		victims.push_back(info);
	}

	void generate_tokens() override
	{
		string assist_counter = "+" + victims.length;
		Vec2f offset;
		GUI::GetTextDimensions(assist_counter, offset);
		offset = Vec2f(-offset.x / 2, 0.0f);

		tokens.push_back(MessageToken(assist_counter, SColor(255, 255, 255, 100)));

		for (uint i = 0; i < victims.length; ++i)
		{
			string clantag = victims[i].clantag;

			if (!clantag.isEmpty())
			{
				tokens.push_back(MessageToken(clantag, SColor(255, 127, 127, 127), offset));
			}

			Vec2f clantag_dimensions;
			GUI::GetTextDimensions(clantag, clantag_dimensions);

			string username = victims[i].username;

			Vec2f username_dimensions;
			GUI::GetTextDimensions(username, username_dimensions);

			if (!username.isEmpty())
			{
				tokens.push_back(
					MessageToken(
						username,
						getTeamColor(victims[i].team),
						offset + Vec2f(clantag_dimensions.x + 6.0f, 0.0f)
					)
				);
			}

			offset.y += Maths::Max(clantag_dimensions.y, username_dimensions.y);
		}
	}

	HoverMessage@ try_merge(HoverMessage@ other) override
	{
		AssistMessage@ message = cast<AssistMessage>(other);

		for (uint i = 0; i < message.victims.length; ++i)
		{
			victims.push_back(message.victims[i]);
		}

		return this;
	}
};

/*
	Material change messages. Looks like:

	-100 stone
	-50 wood
	+30 arrows
*/
class MaterialMessage : HoverMessage
{
	string material_name;
	int quantity_change;

	MaterialMessage(string p_name, int p_quantity)
	{
		material_name = getTranslatedString(p_name);
		quantity_change = p_quantity;

		category = MESSAGE_MATERIAL;
	}

	void reset_time() override
	{
		time_left = 2.0f;
	}

	void generate_tokens() override
	{
		string quantity_string;
		SColor quantity_color;

		if (quantity_change < 0)
		{
			quantity_string = "" + quantity_change;
			quantity_color = SColor(255, 255, 150, 0);
		}
		else if (quantity_change == 0)
		{
			return;
		}
		else if (quantity_change > 0)
		{
			quantity_string = "+" + quantity_change;
			quantity_color = SColor(255, 145, 255, 0);
		}

		Vec2f quantity_dimensions;
		GUI::GetTextDimensions(quantity_string, quantity_dimensions);

		Vec2f material_dimensions;
		GUI::GetTextDimensions(material_name, material_dimensions);

		tokens.push_back(MessageToken(quantity_string, quantity_color, Vec2f(-material_dimensions.x + quantity_dimensions.x, 0)));
		tokens.push_back(MessageToken(material_name, color_white));
	}

	HoverMessage@ try_merge(HoverMessage@ other) override
	{
		MaterialMessage@ message = cast<MaterialMessage>(other);

		if (material_name == message.material_name)
		{
			quantity_change += message.quantity_change;
			return this;
		}

		return null;
	}
}

class DamageTakenMessage : HoverMessage
{
	f32 damage;

	DamageTakenMessage(f32 _damage)
	{
		damage = _damage;
		category = MESSAGE_DAMAGETAKEN;
	}

	void reset_time() override
	{
		time_left = 3.0f;
	}

	void generate_tokens() override
	{
		Vec2f taken_dmg_dim;
		string taken_damage = ""+Maths::Round(damage*10 * 10.0f) / 10.0f;
		GUI::GetTextDimensions(taken_damage, taken_dmg_dim);
		taken_dmg_dim.y = 0;

		tokens.push_back(MessageToken("-"+taken_damage, SColor(140,255,55,55), Vec2f(-4, 0)));
	}

	HoverMessage@ try_merge(HoverMessage@ other) override
	{
		DamageTakenMessage@ message = cast<DamageTakenMessage>(other);

		if (message !is null) damage += message.damage;
		return this;
	}
}

class HealTakenMessage : HoverMessage
{
	f32 heal;

	HealTakenMessage(f32 _heal)
	{
		heal = _heal;
		category = MESSAGE_HEALTAKEN;
	}

	void reset_time() override
	{
		time_left = 3.0f;
	}

	void generate_tokens() override
	{
		Vec2f taken_heal_dim;
		string taken_heal = ""+Maths::Round(heal*10 * 10.0f) / 10.0f;
		GUI::GetTextDimensions(taken_heal, taken_heal_dim);
		taken_heal_dim.y = 0;

		tokens.push_back(MessageToken("+"+taken_heal, SColor(140,55,255,55), Vec2f(-4, 0)));
	}

	HoverMessage@ try_merge(HoverMessage@ other) override
	{
		HealTakenMessage@ message = cast<HealTakenMessage>(other);

		if (message !is null) heal += message.heal;
		return this;
	}
}

class DamageDealtMessage : HoverMessage
{
	f32 damage;

	DamageDealtMessage(f32 _damage)
	{
		damage = _damage;
		category = MESSAGE_DAMAGEDEALT;
	}

	void reset_time() override
	{
		time_left = 4.5f;
	}

	void generate_tokens() override
	{
		Vec2f dealt_dmg_dim;
		string dealt_damage = ""+Maths::Round(damage*5 * 10.0f) / 10.0f;
		GUI::GetTextDimensions(dealt_damage, dealt_dmg_dim);
		dealt_dmg_dim.y = 0;

		tokens.push_back(MessageToken("DMG +"+dealt_damage, SColor(140,255,75,75), Vec2f(-4, 0)));
	}

	HoverMessage@ try_merge(HoverMessage@ other) override
	{
		DamageDealtMessage@ message = cast<DamageDealtMessage>(other);

		if (message !is null) damage += message.damage;
		return this;
	}
}

class HealDealtMessage : HoverMessage
{
	f32 heal;

	HealDealtMessage(f32 _heal)
	{
		heal = _heal;
	}

	void reset_time() override
	{
		time_left = 4.5f;
		category = MESSAGE_HEALDEALT;
	}

	void generate_tokens() override
	{
		Vec2f dealt_dmg_dim;
		string dealt_heal = ""+Maths::Round(heal*10 * 10.0f) / 10.0f;
		GUI::GetTextDimensions(dealt_heal, dealt_dmg_dim);
		dealt_dmg_dim.y = 0;

		Vec2f offset = Vec2f(-4,0);
		tokens.push_back(MessageToken("HEAL +"+dealt_heal, SColor(140,75,255,75), Vec2f(-4, 0)));
	}

	HoverMessage@ try_merge(HoverMessage@ other) override
	{
		HealDealtMessage@ message = cast<HealDealtMessage>(other);
		
		if (message !is null) heal += message.heal;
		return this;
	}
}

class HoverMessages
{
	private HoverMessage@[][] messages;

	private Vec2f base_world_offset;
	Vec2f past_total_offset;
	Vec2f past_offset;

	bool was_empty;

	HoverMessages()
	{
		messages.resize(MESSAGE_TOTAL);
	}

	private HoverMessage@ try_merge(HoverMessage@ message, bool reset_time_on_merge)
	{
		for (int i = 0; i < messages[message.category].length; ++i)
		{
			HoverMessage@ result_message = messages[message.category][i].try_merge(@message);

			if (result_message !is null)
			{
				if (reset_time_on_merge)
				{
					result_message.reset_time();
				}

				return @result_message;
			}
		}

		return null;
	}

	HoverMessage@ add_message(HoverMessage@ message, bool reset_time_on_merge)
	{
		HoverMessage@ result_message = try_merge(@message, reset_time_on_merge);

		if (result_message is null)
		{
			@result_message = @message;
			messages[message.category].push_back(@message);
		}

		// Set the font because we need the right font size to be set for GUI::GetTextDimensions.
		GUI::SetFont("menu");
		result_message.refresh_tokens();

		return @result_message;
	}

	// Determines a well aligned origin for the hover messages.
	Vec2f determine_ideal_position()
	{
		CBlob@ blob = getLocalPlayerBlob();

		if (blob is null)
		{
			return base_world_offset;
		}

		Vec2f pos = blob.getInterpolatedPosition();

		// HACK: For some reason text dimensions need to be divided by two to get real values..? TODO figure out the issue in engine
		pos -= Vec2f(past_total_offset.x * 0.5f * 0.5f, past_total_offset.y * 0.5f + 48.0f) / getCamera().targetDistance;

		return pos;
	}

	void render()
	{
		Vec2f screen_position = getDriver().getScreenPosFromWorldPos(base_world_offset);

		past_total_offset = Vec2f_zero;

		GUI::SetFont("menu");

		was_empty = true;
		for (int c = 0; c < MESSAGE_TOTAL; ++c)
		{
			for (int i = 0; i < messages[c].length; ++i)
			{
				past_offset = Vec2f_zero;

				messages[c][i].render(@this, screen_position);

				// Vertically offset the next message (of the same category)
				screen_position.y -= past_offset.y - Maths::Min(messages[c][i].kickout_effect, past_offset.y + 8);

				was_empty = false;
			}

			// Increase offset between different message categories.
			// This adds up to the offset applied above!
			if (!messages[c].isEmpty())
			{
				screen_position.y -= 8.0f;
			}
		}

		if (!was_empty)
		{
			// Subtly smooth out the movement for the messages
			// This makes it look better when new notices are inserted and offset the ideal position
			base_world_offset = lerp(
				base_world_offset,
				determine_ideal_position(),
				0.7f * getRenderApproximateCorrectionFactor()
			);
		}
		else
		{
			// This way, when the first message pops up it's right in place and doesn't need to move around
			// It kicks in 1 frame too late, but that isn't even noticeable..
			base_world_offset = determine_ideal_position();
		}
	}

	// Remove faded away notices
	void garbage_collect()
	{
		for (int c = 0; c < MESSAGE_TOTAL; ++c)
		for (int i = 0; i < messages[c].length;)
		{
			if (messages[c][i].time_left <= 0.0f
			 || messages[c][i].force_gc)
			{
				messages[c].erase(i);
			}
			else
			{
				++i;
			}
		}
	}
};

// Returns the HoverMessages from rules, and creates it if not done already.
HoverMessages@ get_messages()
{
	CRules@ rules = getRules();
	if (rules is null) return null;

	HoverMessages@ messages;
	rules.get("hover messages", @messages);

	if (messages is null)
	{
		HoverMessages created_messages;
		rules.set("hover messages", @created_messages);
		return @created_messages;
	}

	return @messages;
}

// Adds a hover message to the list, which may get merged into existing ones.
// e.g. add_message(MyCustomMessage(42, "hello"));
HoverMessage@ add_message(HoverMessage@ message, bool reset_time_on_merge = true)
{
	return get_messages().add_message(message, reset_time_on_merge);
}
